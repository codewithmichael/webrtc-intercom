<!--
Project: WebRTC Intercom
Created: 2020.05.31
Author:  Michael Spencer <code.with.michael@gmail.com>
License: MIT
-->
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Intercom</title>
    <script>
        "use strict";
        const DEFAULT_USERNAME = 'My User'
        const DEBUG_LOGGING    = true
    </script>
    <style>
        * {
            font-family: Arial, Helvetica, sans-serif;
            user-select: none;
        }


        [data-type="template"] {
            display: none !important;
        }


        #name-input {
            display: block;
            outline: none;
            padding: 0;
            border: 0;
            border-bottom: 1px solid #ccc;
            font-size: 16px;
            user-select: text;
        }
        

        #user-list {
            display: inline-block;
            list-style: none;
            margin: 0;
            padding: 0;
            font-size: 16px;
            margin: 10px 0;
        }
        #user-list li:not(:last-child) {
            margin-bottom: 10px;
        }
        #user-list .user-item {
            display: block;
            position: relative;
            padding-right: 55px;
        }
        #user-list .user-item >* {
            display: inline-block;
            line-height: 20px;
            vertical-align: middle;
        }


        #user-list audio {
            display: none !important;
        }


        #user-list .light {
            width: 14px;
            height: 14px;
            border-radius: 14px;
            border: 1px solid #ccc;
            background-color: #ccc;
        }
        #user-list .light.on {
            background-color: #afa;
        }


        #user-list .toggle::before {
            display: inline-block;
            content: "off";
            width: 50px;
            color: #fff;
            background-color: #444;
            text-align: center;
        }
        #user-list .toggle.on::before {
            content: "on";
            background-color: #f00;
        }


        #user-list .button {
            position: absolute;
            right: 25px;
            width: 20px;
            height: 20px;
            border-radius: 20px;
            border: 1px solid #888;
            background-color: #888;
            box-shadow: inset 2px 2px 3px -3px #fff;
        }
        #user-list .button.pressed {
            box-shadow: inset 2px 2px 3px -2px #000;
        }
        #user-list .button::before {
            display: inline-block;
            position: relative;
            content: "talk";
            font-size: 10px;
            line-height: 24px;
            height: 24px;
            top: -3px;
            left: -3px;
            border: 1px solid #ccc;
            border-radius: 20px 0 0 20px;
            background-color: #eee;
            padding: 0 5px 0 26px;
            z-index: -1;
        }
    </style>
</head>
<body>

    <input id="name-input" type="text" placeholder="Enter User Name"/>
    <ul id="user-list">
        <li class="user-item" data-type="template">
            <audio autoplay></audio>
            <span class="light"></span>
            <span class="toggle"></span>
            <span class="name">UserName</span>
            <span class="button"></span>
        </li>
    </ul>


    <script>(async () => {
        "use strict";


        //-[ Setup ]----------------------------------------------------------


        const {
            inputAudioStream,
            nameInput,
            userList,
            updateUserItems,
            sendMessage,
        } = Object.assign(this,
            await prepareInputAudioStream(),
            await prepareUserInterface(),
            await prepareMessaging(),
        )

        
        
        //-[ App ]------------------------------------------------------------


        let state = this.state = {
            user: { name: DEFAULT_USERNAME },
            users: [],
            connections: {}  // { <key=user_id>: { connection, dataChannel, localStream, remoteStream }}
        }
        
        // Mute microphone by default
        disableAudioTracks(inputAudioStream)

        // Handle name change
        nameInput.value = state.user.name
        nameInput.onblur = () => {
            const name = nameInput.value.trim()
            nameInput.value = name
            if (name === state.user.name) return
            register(name)
                .catch(error => {
                    console.error(error)
                    nameInput.value = state.user.name
                })
        }

        // Autoconnect
        const { name } = state.user
        if (name) await register(name)


        //-[ Functions ]------------------------------------------------------


        function toUser(data) {
            let { id, name } = data || {}
            if (typeof(id) === 'undefined') id = null
            name = (name || '').trim()
            return { id, name }
        }


        function onReceiveUser(user) {
            user = toUser(user)
            state.user = user
            nameInput.value = user.name
        }


        function onReceiveUsers(users) {
            users = (users || [])
                // .filter(user => user.id !== state.user.id)
                .map(toUser)
            state.users = users
            let userItems = state.userItems = updateUserItems(users)

            userItems.forEach((userItem, index) => {
                const user = users[index]
                user.userItem = userItem

                const { audio, toggle, button } = userItem
                toggle.onenable  = onToggleEnable
                toggle.ondisable = onToggleDisable

                function onToggleEnable() {
                    performOffer(user.id)
                        .then(({ connection, offer, response }) => {
                            let [offerConnection, offerResponse] = [connection, response]
                            return { offerConnection, offer, offerResponse }
                        })
                        .then(async ({ offerConnection, offer, offerResponse }) => {
                            let { connection, answer, response } = await performAnswer(offer, state.user.id)
                            let [answerConnection, answerResponse] = [connection, response]
                            return { offerConnection, answerConnection, offer, answer, offerResponse, answerResponse }
                        })
                        .then(({ offerConnection, answerConnection, offer, answer, offerResponse, answerResponse }) => {
                            acceptAnswer(offerConnection, answer)
                            state.connections[user.id].answer = answer
                        })
                }

                function onToggleDisable() {
                    disconnect(user.id)
                }
            })
        }

        
        async function register(name) {
            let message = { register: name }
            let { id } = state.user
            if (typeof(id) !== 'undefined' && id != null) {
                message.id = id
            }
            return sendMessage(message)
                .then(({ user, users }) => {
                    onReceiveUser(user)
                    onReceiveUsers(users)
                })
        }


        async function performOffer(user_id) {
            const user = state.users.find(user => user.id === user_id)
            if (!user) throw new Error('User not found')
            
            await disconnect(user_id)
            const localStream = inputAudioStream ? inputAudioStream.clone() : undefined
            disableAudioTracks(localStream)
            const info = await createOfferConnection(localStream)
            state.connections[user_id] = info

            const { connection } = info
            connection.ontrack = onTrack
            
            const { userItem } = user
            if (userItem) {
                userItem.button.onpress   = () => enableAudioTracks(localStream)
                userItem.button.onrelease = () => disableAudioTracks(localStream)
            }

            const { offer } = info
            const response = sendMessage({ offer, user_id })
                .catch(error => {
                    disconnect(user_id)
                    throw error
                })

            return { connection, offer, response }

            function onTrack(event) {
                const stream = event.streams[0]
                if (stream) {
                    info.remoteStream = stream
                    if (userItem) userItem.audio.srcObject = stream
                }
                debugLog('Added remote WebRTC audio stream')
            }
        }


        async function performAnswer(offer, user_id) {
            const user = state.users.find(user => user.id === user_id)
            if (!user) throw new Error('User not found')

            await disconnect(user_id)
            const localStream = inputAudioStream ? inputAudioStream.clone() : undefined
            disableAudioTracks(localStream)
            const info = await createAnswerConnection(offer, localStream)
            state.connections[user_id] = info
            
            const { connection } = info
            connection.ondatachannel = onDataChannel
            connection.ontrack = onTrack

            const { userItem } = user
            if (userItem) {
                userItem.button.onpress   = () => enableAudioTracks(localStream)
                userItem.button.onrelease = () => disableAudioTracks(localStream)
            }

            const { answer } = info
            const response = sendMessage({ answer, user_id })
                .catch(error => {
                    disconnect(user_id)
                    throw error
                })

            return { connection, offer, answer, response }

            function onDataChannel(event) {
                info.dataChannel = event.channel
                debugLog('Added remote WebRTC data channel')
            }

            function onTrack(event) {
                const stream = event.streams[0]
                if (stream) {
                    info.remoteStream = stream
                    if (userItem) userItem.audio.srcObject = stream
                }
                debugLog('Added remote WebRTC audio stream')
            }
        }


        async function disconnect(user_id) {
            const info = state.connections[user_id]
            if (info) {
                delete state.connections[user_id]
                const user = state.users.find(user => user.id === user_id)
                const userItem = (user || {}).userItem
                const {
                    connection,
                    dataChannel,
                    localStream,
                    remoteStream
                } = info
                if (userItem) {
                    userItem.toggle.disable()
                    userItem.audio.srcObject  = undefined
                    userItem.button.onpress   = undefined
                    userItem.button.onrelease = undefined
                }
                if (localStream)  disableAudioTracks(localStream)
                if (remoteStream) disableAudioTracks(remoteStream)
                if (dataChannel)  await closeDataChannel(dataChannel)
                if (connection)   await closeConnection(connection)
                debugLog('Disconnected from user: ' + user.name)
                return true
            }
            return false
        }


        // =[ UI ]============================================================


        async function prepareUserInterface() {
            const nameInput = document.querySelector('#name-input')
            const userList  = document.querySelector('#user-list')
            const templates = {
                userItem: userList.querySelector('.user-item[data-type="template"]')
            }
            Object.keys(templates).forEach(k => { templates[k].remove() })
            const updateUserItems = users => _updateUserItems(users, userList, templates.userItem)

            nameInput.onfocus = onNameInputFocus
            nameInput.onkeydown = onNameInputKeyDown

            return {
                templates, nameInput, userList,
                updateUserItems
            }
            
            function onNameInputFocus(event) {
                this.select()
            }

            function onNameInputKeyDown(event) {
                if (event.key === 'Enter') this.blur()
            }
        }

        
        function _updateUserItems(users, userList, userItemTemplate) {
            userList.innerHTML = ''
            return (users || [])
                .map(user => _createUserItem(user, userItemTemplate))
                .map(userItem => (userList.appendChild(userItem), userItem))
        }


        function _createUserItem(user, template) {
            const userItem = template.cloneNode(true)
            delete userItem.dataset.type

            const audio  = userItem.querySelector('audio')
            const name   = userItem.querySelector('.name')
            const toggle = userItem.querySelector('.toggle')
            const button = userItem.querySelector('.button')
            const light  = userItem.querySelector('.light')

            name.innerHTML     = user.name

            toggle.isEnabled   = function() { return this.classList.contains('on') }
            toggle.enable      = function() { if (this.isEnabled()) return; this.classList.add('on'); if (this.onenable) this.onenable() }
            toggle.disable     = function() { if (!this.isEnabled()) return; this.classList.remove('on'); if (this.ondisable) this.ondisable() }
            toggle.toggle      = function() { this.isEnabled() ? this.disable() : this.enable() }
            toggle.onclick     = function() { this.toggle() }
            toggle.onenable    = undefined
            toggle.ondisable   = undefined

            button.isPressed   = function() { return this.classList.contains('pressed') }
            button.onmousedown = function() { if (!toggle.isEnabled()) return; this.classList.add('pressed'); if (this.onpress) this.onpress() }
            button.onmouseup   =
            button.onmouseout  = function() { this.classList.remove('pressed'); if (this.onrelease) this.onrelease() }
            button.onpress     = undefined
            button.onrelease   = undefined
            
            light.isEnabled    = function() { return this.classList.contains('on') }
            light.enable       = function() { this.classList.add('on') }
            light.disable      = function() { this.classList.remove('on') }
            light.toggle       = function() { this.isEnabled() ? this.disable() : this.enable() }
            light.isFlashing   = function() { return !!this._flashInterval }
            light.flash        = function() { this.enable(); this._flashInterval = setInterval(() => this.toggle(), 1000) }
            light.cancelFlash  = function() { clearInterval(this._flashInterval); delete this._flashInterval; this.disable() }

            Object.assign(userItem, { audio, name, button, toggle, light })
            
            return userItem
        }


        // =[ Audio ]=========================================================


        async function prepareInputAudioStream() {
            const inputAudioStream = await navigator.mediaDevices
                .getUserMedia({ audio: true })
                .then(stream => {
                    let track = stream.getAudioTracks()[0]
                    if (track) debugLog("Using audio device: " + track.label)
                    return stream
                })
                .catch(error => { console.error(error) })
            return { inputAudioStream }
        }


        function enableAudioTrack(track, enable=true) {
            if (track.enabled === enable) return
            track.enabled = enable
            debugLog(`${enable ? "Enabled" : "Disabled"} audio device: ${track.label}`)
        }


        function enableAudioTracks(stream, enable=true) {
            if (!stream) return
            stream.getAudioTracks().forEach(track => enableAudioTrack(track, enable))
        }


        function disableAudioTracks(stream) {
            enableAudioTracks(stream, false)
        }


        // =[ WebRTC ]========================================================


        async function createConnection() {
            const connection = new RTCPeerConnection()
            debugLog('Created WebRTC connection')
            return connection
        }


        async function closeConnection(connection) {
            connection.close()
            debugLog('Closed WebRTC connection')
        }


        async function waitForIceCandidates(connection) {
            return new Promise(resolve => {
                connection.addEventListener('icecandidate', onIceCandidate)

                function onIceCandidate(event) {
                    if (event.candidate) return
                    connection.removeEventListener('icecandidate', onIceCandidate)
                    debugLog('WebRTC Ice candidates received')
                    resolve(connection)
                }
            })
        }


        async function createDataChannel(connection) {
            const channel = connection.createDataChannel('data')
            debugLog('Created WebRTC data channel')
            return channel
        }


        async function closeDataChannel(channel) {
            channel.close()
            debugLog('Closed WebRTC data channel')
        }


        async function sendDataChannelMessage(channel, message) {
            channel.send(message)
            debugLog('Sent WebRTC data channel message: ', message)
        }


        async function addTracks(connection, stream) {
            stream.getAudioTracks().forEach(track => {
                connection.addTrack(track, stream)
                debugLog("Created WebRTC audio track for device: " + track.label)
            })
        }


        async function createOffer(connection, options) {
            const offer = await connection.createOffer(options)
            debugLog('Created WebRTC offer')
            return offer
        }


        async function setOffer(connection, offer) {
            const waitForSdp = waitForIceCandidates(connection)
            await connection.setLocalDescription(offer)
            await waitForSdp
            offer.sdp = connection.localDescription.sdp
            debugLog("Applied local WebRTC offer")
            return offer
        }


        async function acceptOffer(connection, offer) {
            await connection.setRemoteDescription(offer)
            debugLog('Applied remote WebRTC offer')
        }
        

        async function createAnswer(connection) {
            const answer = await connection.createAnswer()
            debugLog('Created WebRTC answer')
            return answer
        }


        async function setAnswer(connection, answer) {
            const waitForSdp = waitForIceCandidates(connection)
            await connection.setLocalDescription(answer)
            await waitForSdp
            answer.sdp = connection.localDescription.sdp
            debugLog("Applied local WebRTC answer")
            return answer
        }


        async function acceptAnswer(connection, answer) {
            await connection.setRemoteDescription(answer)
            debugLog('Appled remote WebRTC answer')
        }


        async function createOfferConnection(stream) {
            const connection  = await createConnection()
            const dataChannel = await createDataChannel(connection)
            if (stream) await addTracks(connection, stream)
            const offer       = await createOffer(connection)
            await setOffer(connection, offer)
            return { connection, dataChannel, localStream: stream, offer }
        }


        async function createAnswerConnection(offer, stream) {
            const connection  = await createConnection()
            await acceptOffer(connection, offer)
            if (stream) await addTracks(connection, stream)
            const answer      = await createAnswer(connection)
            await setAnswer(connection, answer)
            return { connection, localStream: stream, offer, answer }
        }


        // =[ Messaging ]=====================================================


        async function prepareMessaging() {
            const sendMessage = _sendMessage
            return { sendMessage }
        }


        async function _sendMessage(data) {
            debugLog('Sending message: ', data)

            // Register user
            // { register: name}     => { register: { id, name }, users }
            // { register: name, id} => { register: { id, name }, users }
            if (data.hasOwnProperty('register')) {
                let { id, register:name } = data
                if (!name) throw new Error('Name required')
                let user = { register: id || 'you', name }
                let users = [ { name }, { name: 'Other User' } ]
                return { user, users }
            }


            // Unregister user
            // { unregister: id } => undefined
            if (data.hasOwnProperty('register')) {
                let { id } = data
                if (!id) throw new Error('User ID required')
                return undefined
            }


            // Offer connection (from id to name)
            // { id, offer, name } => undefined
            if (data.hasOwnProperty('offer')) {
                let { id, offer, name } = data
                if (!id) throw new Error('User ID required')
                if (!offer) throw new Error('Offer required')
                if (!name) throw new Error('User name required')
                return { id, answer: null, name }
            }

            // Answer connection offer (from id to name)
            // { id, answer, name } => undefined
            if (data.hasOwnProperty('answer')) {
                let { id, answer, name } = data
                if (!id) throw new Error('User ID required')
                if (!answer) throw new Error('Answer required')
                if (!name) throw new Error('User name required')
                return undefined
            }

            // Wait for message(s)
            // { wait: id } => undefined
            // { wait: id } => { messages: [] }
            //      message = { user, users }
            //      message = { offer, name }
            //      message = { answer, name }
            if (data.hasOwnProperty('wait')) {
                return undefined
            }

            throw new Error('Invalid message')
        }


        // =[ Utility ]=======================================================


        function debugLog(message) {
            if (DEBUG_LOGGING) console.log(...arguments)
        }
    })()</script>

</body>
</html>