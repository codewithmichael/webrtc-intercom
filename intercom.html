<!--
Project: WebRTC Intercom
Created: 2020.05.31
Author:  Michael Spencer <code.with.michael@gmail.com>
License: MIT
-->
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Intercom</title>
    <script>
        "use strict";
        
        const DEFAULT_USERNAME = 'My User'
        
        // Messaging server info
        const PROTO  = 'http'
        const SERVER = 'localhost'
        const PORT   = 8080
        const PATH   = '/jsonLoader'

        const MESSAGE_TIMEOUT   = 3000
        const LONG_POLL_TIMEOUT = 30000

        const DEBUG_LOGGING    = true
    </script>
    <style>
        * {
            font-family: Arial, Helvetica, sans-serif;
            user-select: none;
        }


        [data-type="template"] {
            display: none !important;
        }


        #name-input {
            display: block;
            outline: none;
            padding: 0;
            border: 0;
            border-bottom: 1px solid #ccc;
            font-size: 16px;
            user-select: text;
        }
        

        #user-list {
            display: inline-block;
            list-style: none;
            margin: 0;
            padding: 0;
            font-size: 16px;
            margin: 10px 0;
        }
        #user-list li:not(:last-child) {
            margin-bottom: 10px;
        }
        #user-list .user-item {
            display: block;
            position: relative;
            padding-right: 55px;
        }
        #user-list .user-item >* {
            display: inline-block;
            line-height: 20px;
            vertical-align: middle;
        }


        #user-list audio {
            display: none !important;
        }


        #user-list .light {
            position: relative;
            --light-off-color: #ccc;
            --light-on-color: #6f6;
            --light-flash-color: #6f6;
            width: 14px;
            height: 14px;
            border-radius: 14px;
            border: 1px solid var(--light-off-color);
            background-color: var(--light-off-color);
        }
        #user-list .light.on {
            background-color: var(--light-on-color);
        }
        @keyframes flashing{
            0%  { background-color: var(--light-flash-color); }
            49% { background-color: var(--light-flash-color); }
            50% { background-color: var(--light-off-color); }
            100%{ background-color: var(--light-off-color); }
        }
        #user-list .light.flashing{
            animation:flashing 1s infinite;
        }
        #user-list .light.flashing::before {
            display: block;
            position: absolute;
            white-space: nowrap;
            content: "cancel";
            font-size: 9px;
            line-height: 9px;
            top: -11px;
            left: 50%;
            transform: translateX(-50%);
            height: 9px;
        }


        #user-list .toggle::before {
            display: inline-block;
            content: "off";
            width: 50px;
            color: #fff;
            background-color: #444;
            text-align: center;
            margin: 0 5px;
        }
        #user-list .toggle.on::before {
            content: "on";
            background-color: #f00;
        }
        #user-list .toggle.waiting::before {
            content: "â€¦";
            background-color: #66f;
        }


        #user-list .button {
            position: absolute;
            right: 25px;
            width: 20px;
            height: 20px;
            border-radius: 20px;
            border: 1px solid #888;
            background-color: #888;
            box-shadow: inset 2px 2px 3px -3px #fff;
        }
        #user-list .button.pressed {
            box-shadow: inset 2px 2px 3px -2px #000;
        }
        #user-list .button::before {
            display: inline-block;
            position: relative;
            content: "talk";
            font-size: 10px;
            line-height: 24px;
            height: 24px;
            top: -3px;
            left: -3px;
            border: 1px solid #ccc;
            border-radius: 20px 0 0 20px;
            background-color: #eee;
            padding: 0 5px 0 26px;
            z-index: -1;
        }
    </style>
</head>
<body>

    <input id="name-input" type="text" placeholder="Enter User Name"/>
    <ul id="user-list">
        <li class="user-item" data-type="template">
            <audio autoplay></audio>
            <span class="light"></span>
            <span class="toggle"></span>
            <span class="name">UserName</span>
            <span class="button"></span>
        </li>
        <li class="no-users" data-type="template">
            No other users connected
        </li>
    </ul>


    <script>(async () => {
        "use strict";


        //-[ Setup ]----------------------------------------------------------


        const {
            inputAudioStream,
            nameInput,
            userList,
            updateUserItems,
            sendMessage,
        } = Object.assign(this,
            await prepareInputAudioStream(),
            await prepareUserInterface(),
            await prepareMessaging(),
        )
        
        
        //-[ App ]------------------------------------------------------------


        let state = this.state = {
            user: { name: DEFAULT_USERNAME },
            users: [],
            connections: {}  // { <key=user_name>: { connection, dataChannel, localStream, remoteStream, offer, answer }}
        }
        
        // Mute microphone by default
        disableAudioTracks(inputAudioStream)

        // Handle name change
        if (nameInput.value) {
            nameInput.value = nameInput.value.trim()
            if (nameInput.value) state.user.name = nameInput.value
        }
        nameInput.value = state.user.name
        nameInput.onblur = () => {
            const name = nameInput.value.trim()
            nameInput.value = name
            register(name)
                .catch(error => {
                    console.error(error)
                    nameInput.value = state.user.name || ''
                })
        }

        // Autoconnect
        const { name } = state.user
        if (name) await register(name)


        //-[ Data ]-----------------------------------------------------------


        function toUser(data) {
            let { id, name } = data || {}
            if (typeof(id) === 'undefined') id = null
            name = (name || '').trim()
            return { id, name }
        }


        //-[ Actions ]--------------------------------------------------------

        
        async function register(name) {
            let message = { register: name }
            let { id } = state.user
            if (typeof(id) !== 'undefined' && id != null) {
                message.id = id
            }
            return sendMessage(message)
                .then(({ register: user, users }) => {
                    onReceiveUser(user)
                    onReceiveUsers(users)
                })
                .then(() => {
                    loopWait() // not returned!
                })
        }


        async function performOffer(name) {
            const targetUser = state.users.find(user => user.name === name)
            if (!targetUser) throw new Error('User not found')

            const { userItem } = targetUser
            if (!userItem) throw new Error(`Display element not found for user: ${targetUser.name}`)
            
            await disconnect(name)
            const localStream = inputAudioStream ? inputAudioStream.clone() : undefined
            disableAudioTracks(localStream)

            userItem.toggle.wait()
            userItem.button.onpress   = onPress
            userItem.button.onrelease = onRelease

            const info = { name }
            Object.assign(info, await createOfferConnection(localStream, onTrack))
            state.connections[name] = info

            const { connection, dataChannel, offer } = info
            dataChannel.onopen  = onOpen
            dataChannel.onclose = onClose
            dataChannel.onmessage = onMessage

            const message = {
                id: state.user.id,
                offer: JSON.stringify(offer),
                name
            }
            const response = sendMessage(message)
                .catch(error => {
                    disconnect(name)
                    throw error
                })

            return { connection, offer, response }

            function onTrack(event) {
                const stream = event.streams[0]
                if (stream) {
                    info.remoteStream = stream
                    if (userItem) userItem.audio.srcObject = stream
                }
                debugLog('Added remote WebRTC audio stream')
            }

            function onOpen(event) {
                userItem.toggle.enable()
            }

            function onClose(event) {
                debugLog(`Data connection closed for user: ${name}`)
                disconnect(name)
            }

            function onMessage(event) {
                let { data } = event
                if (!data) return
                let { name } = info
                let { userItem } = state.users.filter(u => u.name === name)[0] || {}
                switch (data) {
                    case "begin_talk":
                        info.isTalking = true
                        if (userItem) userItem.light.enable()
                        break;
                    case "end_talk":
                        info.isTalking = false
                        if (userItem) userItem.light.disable()
                        break;
                    default:
                        console.error(`Unknown data channel message received: "${data}"`)
                }
            }

            function onPress(event) {
                enableAudioTracks(localStream)
                dataChannel.send("begin_talk")
            }

            function onRelease(event) {
                disableAudioTracks(localStream)
                dataChannel.send("end_talk")
            }
        }


        async function performAnswer(offer, name) {
            const targetUser = state.users.find(user => user.name === name)
            if (!targetUser) throw new Error('User not found')
            
            const { userItem } = targetUser
            if (!userItem) throw new Error(`Display element not found for user: ${targetUser.name}`)
            
            await disconnect(name)
            const localStream = inputAudioStream ? inputAudioStream.clone() : undefined
            disableAudioTracks(localStream)
                        
            userItem.button.onpress   = onPress
            userItem.button.onrelease = onRelease

            const info = { name } // must exist before calling createAnswerConneciton (for onTrack)
            Object.assign(info, await createAnswerConnection(offer, localStream, onTrack, onDataChannel))
            state.connections[name] = info

            let { answer } = info
            answer = JSON.stringify(answer)
            const response = sendMessage({ id: state.user.id, answer, name })
                .catch(error => {
                    disconnect(name)
                    throw error
                })

            
            const { connection } = info
            return { connection, offer, answer, response }

            function onDataChannel(event) {
                info.dataChannel = event.channel
                info.dataChannel.onclose = onClose
                info.dataChannel.onmessage = onMessage

                userItem.toggle.enable()
                userItem.light.cancelFlash()
                
                debugLog('Added remote WebRTC data channel')
            }

            function onTrack(event) {
                const stream = event.streams[0]
                if (stream) {
                    info.remoteStream = stream
                    if (userItem) userItem.audio.srcObject = stream
                }
                debugLog('Added remote WebRTC audio stream')
            }

            function onClose(event) {
                debugLog(`Data connection closed for user: ${name}`)
                disconnect(name)
            }

            function onMessage(event) {
                let { data } = event
                if (!data) return
                let { name } = info
                let { userItem } = state.users.filter(u => u.name === name)[0] || {}
                switch (data) {
                    case "begin_talk":
                        info.isTalking = true
                        if (userItem) userItem.light.enable()
                        break;
                    case "end_talk":
                        info.isTalking = false
                        if (userItem) userItem.light.disable()
                        break;
                    default:
                        console.error(`Unknown data channel message received: "${data}"`)
                }
            }

            function onPress(event) {
                let { localStream, dataChannel } = info || {}
                if (localStream) enableAudioTracks(localStream)
                if (dataChannel) dataChannel.send("begin_talk")
            }

            function onRelease(event) {
                let { localStream, dataChannel } = info || {}
                if (localStream) disableAudioTracks(localStream)
                if (dataChannel) dataChannel.send("end_talk")
            }
        }


        async function disconnect(name) {
            const info = state.connections[name]
            if (info) {
                delete state.connections[name]
                const targetUser = state.users.find(user => user.name === name)
                const userItem = (targetUser || {}).userItem
                const {
                    connection,
                    dataChannel,
                    localStream,
                    remoteStream
                } = info
                if (userItem) {
                    userItem.toggle.disable()
                    userItem.light.cancelFlash()
                    userItem.audio.srcObject  = undefined
                    userItem.button.onpress   = undefined
                    userItem.button.onrelease = undefined
                }
                if (localStream)  disableAudioTracks(localStream)
                if (remoteStream) disableAudioTracks(remoteStream)
                if (dataChannel)  await closeDataChannel(dataChannel)
                if (connection)   await closeConnection(connection)
                debugLog('Disconnected from user: ' + targetUser.name)
                return true
            }
            return false
        }


        var _cancelLoopWait
        function cancelLoopWait() {
            if (_cancelLoopWait) _cancelLoopWait()
            _cancelLoopWait = undefined
        }


        async function loopWait() {
            let cancelled = false

            cancelLoopWait()
            _cancelLoopWait = cancel
            return startLoop()

            function cancel() {
                cancelled = true
            }

            async function startLoop() {
                while (!cancelled && state.user && state.user.id) {
                    await sendMessage({ wait: state.user.id }, LONG_POLL_TIMEOUT)
                        .then(response => {
                            if (cancelled) return
                            let { messages } = response
                            if (messages) for (let message of messages) {
                                onReceiveMessage(message)
                            }
                        })
                        .catch(error => {
                            if (error.name === 'AbortError') return
                            console.error(error)
                            cancel()
                        })
                }
            }
        }


        //-[ Events ]--------------------------------------------------------


        function onReceiveMessage(message)
        {
            if (!message || !state.user || !state.user.id) return

            let { register, unregister, offer, answer, reject } = message

            if (register) {
                let { register: user, users } = message
                onReceiveUser(user)
                onReceiveUsers(users)
            } else if (unregister) {
                let { unregister: user, users } = message
                disconnect(user.name)
                onReceiveUsers(users)
            } else if (offer) {
                let { name } = message
                onReceiveOffer(offer, name)
                    .catch(error => {
                        disconnect(name)
                        return error
                    })
            } else if (answer) {
                let { name } = message
                onReceiveAnswer(answer, name)
                    .catch(error => {
                        disconnect(name)
                        return error
                    })
            } else if (reject) {
                let { reject: user } = message
                let { name } = user
                onReceiveReject(name)
                    .catch(error => {
                        disconnect(name)
                        return error
                    })
            }
        }


        function onReceiveUser(user) {
            let { id, name, old_name } = user
            if (id) {
                user = toUser(user)
                state.user = user
                nameInput.value = name
            } else if (old_name) {
                if (state.connections[old_name]) {
                    state.connections[name] = state.connections[old_name]
                    state.connections[name].name = name
                    delete state.connections[old_name]
                }
            }
        }


        function onReceiveUsers(users) {
            users = (users || [])
                .filter(user => user.name !== state.user.name)
                .map(toUser)
            state.users = users
            let userItems = state.userItems = updateUserItems(users)

            userItems.forEach((userItem, index) => {
                const user = users[index]
                user.userItem = userItem

                const { audio, light, toggle, button } = userItem
                let info = state.connections[user.name]
                let {
                    connection,
                    offer,
                    answer,
                    remoteStream,
                    isTalking
                } = info || {}

                audio.srcObject  = remoteStream
                light.onclick    = onLightClick
                toggle.onclick   = onToggleClick
                button.onpress   = onButtonPress
                button.onrelease = onButtonRelease

                if (isTalking) light.enable()

                if (offer) {
                    if (connection) {
                        if (answer) {
                            toggle.enable()
                        } else {
                            toggle.wait()
                        }
                    } else {
                        light.flash()
                    }
                }

                function onToggleClick() {
                    let info = state.connections[user.name]
                    let { connection, offer, answer } = info || {}
                    if (!info) {
                        // No connection: Make an offer
                        performOffer(user.name)
                    } else if (offer && !connection) {
                        // Have a connection offer: Accept offer
                        performAnswer(offer, user.name)
                    } else {
                        // Connected: Disconnect
                        disconnect(user.name)
                        if (connection && offer && !answer) {
                            // Other user hasn't accept connection offer
                            sendMessage({ id: state.user.id, reject: user.name })
                        }
                    }
                }

                function onLightClick() {
                    let { connection, offer } = state.connections[user.name] || {}
                    if (offer && !connection) {
                        disconnect(user.name)
                        sendMessage({ id: state.user.id, reject: user.name })
                    }
                }

                function onButtonPress(event) {
                    let { localStream, dataChannel } = state.connections[user.name] || {}
                    if (localStream) enableAudioTracks(localStream)
                    if (dataChannel) dataChannel.send("begin_talk")
                }

                function onButtonRelease(event) {
                    let { localStream, dataChannel } = state.connections[user.name] || {}
                    if (localStream) disableAudioTracks(localStream)
                    if (dataChannel) dataChannel.send("end_talk")
                }
            })
        }


        async function onReceiveOffer(offer, name) {
            let sourceUser = state.users.filter(user => user.name === name)[0]
            if (!sourceUser) throw new Error(`Received offer from unknown user "${name}"... skipping`)

            let { userItem } = sourceUser
            if (!userItem) throw new Error(`Display element not found for user: ${sourceUser.name}`)
            
            await disconnect(name)
            offer = JSON.parse(offer)
            state.connections[name] = { offer }

            userItem.light.flash()
        }


        async function onReceiveAnswer(answer, name) {
            let sourceUser = state.users.filter(user => user.name === name)[0]
            if (!sourceUser) throw new Error(`Received answer from unknown user "${name}"... skipping`)

            let info = state.connections[name]
            let { connection, offer } = info || {}
            if (!info || !connection || !offer || info.answer) {
                throw new Error(`Received unprompted answer from user "${name}"... skipping`)
            }

            answer = JSON.parse(answer)
            return acceptAnswer(connection, answer)
                .then(() => {
                    info.answer = answer
                    return answer
                })
                .catch(error => {
                    disconnect(name)
                    throw error
                })
        }


        async function onReceiveReject(name) {
            disconnect(name)
        }


        // =[ UI ]============================================================


        async function prepareUserInterface() {
            const nameInput = document.querySelector('#name-input')
            const userList  = document.querySelector('#user-list')
            const templates = {
                userItem: userList.querySelector('.user-item[data-type="template"]'),
                noUsers:  userList.querySelector('.no-users[data-type="template"]'),
            }
            Object.keys(templates).forEach(k => { templates[k].remove() })
            const updateUserItems = users => _updateUserItems(
                users, userList, templates.userItem, templates.noUsers)

            nameInput.onfocus = onNameInputFocus
            nameInput.onkeydown = onNameInputKeyDown

            return {
                templates, nameInput, userList,
                updateUserItems
            }
            
            function onNameInputFocus(event) {
                this.select()
            }

            function onNameInputKeyDown(event) {
                if (event.key === 'Enter') this.blur()
            }
        }

        
        function _updateUserItems(users, userList, userItemTemplate, noUsersTemplate) {
            userList.innerHTML = ''
            if (!users || !users.length) {
                const noUsers = noUsersTemplate.cloneNode(true)
                delete noUsers.dataset.type
                userList.appendChild(noUsers)
                return []
            } else {
                return (users || [])
                    .map(user => _createUserItem(user, userItemTemplate))
                    .map(userItem => (userList.appendChild(userItem), userItem))
            }
        }


        function _createUserItem(user, template) {
            const userItem = template.cloneNode(true)
            delete userItem.dataset.type

            const audio  = userItem.querySelector('audio')
            const name   = userItem.querySelector('.name')
            const toggle = userItem.querySelector('.toggle')
            const button = userItem.querySelector('.button')
            const light  = userItem.querySelector('.light')

            name.innerHTML     = user.name

            toggle.isEnabled   = function() { return this.classList.contains('on') }
            toggle.isWaiting   = function() { return this.classList.contains('waiting') }
            toggle.isDisabled  = function() { return !this.isEnabled() && !this.isWaiting() }
            toggle.enable      = function() { if (this.isEnabled()) return; this.classList.remove('waiting'); this.classList.add('on'); if (this.onenable) this.onenable() }
            toggle.disable     = function() { if (!this.isEnabled() && !this.isWaiting()) return; this.classList.remove('on', 'waiting'); if (this.ondisable) this.ondisable() }
            toggle.wait        = function() { if (this.isWaiting()) return; this.classList.remove('on'); this.classList.add('waiting'); if (this.onwait) this.onwait() }
            toggle.onenable    = undefined
            toggle.ondisable   = undefined
            toggle.onwait      = undefined

            button.isPressed   = function() { return this.classList.contains('pressed') }
            button.onmousedown = function() { if (!toggle.isEnabled()) return; this.classList.add('pressed'); if (this.onpress) this.onpress() }
            button.onmouseup   =
            button.onmouseout  = function() { this.classList.remove('pressed'); if (this.onrelease) this.onrelease() }
            button.onpress     = undefined
            button.onrelease   = undefined
            
            light.isEnabled    = function() { return this.classList.contains('on') }
            light.enable       = function() { this.classList.add('on') }
            light.disable      = function() { this.classList.remove('on') }
            light.toggle       = function() { this.isEnabled() ? this.disable() : this.enable() }
            light.isFlashing   = function() { return this.classList.contains('flashing') }
            light.flash        = function() { this.classList.add('flashing') }
            light.cancelFlash  = function() { this.classList.remove('flashing') }

            Object.assign(userItem, { audio, name, button, toggle, light })
            
            return userItem
        }


        // =[ Audio ]=========================================================


        async function prepareInputAudioStream() {
            if (!navigator.mediaDevices) throw new Error("No media devices available")
            const inputAudioStream = await navigator.mediaDevices
                .getUserMedia({ audio: true })
                .then(stream => {
                    let track = stream.getAudioTracks()[0]
                    if (track) debugLog("Using audio device: " + track.label)
                    return stream
                })
                .catch(error => { console.error(error) })
            return { inputAudioStream }
        }


        function enableAudioTrack(track, enable=true) {
            if (track.enabled === enable) return
            track.enabled = enable
            debugLog(`${enable ? "Enabled" : "Disabled"} audio device: ${track.label}`)
        }


        function enableAudioTracks(stream, enable=true) {
            if (!stream) return
            stream.getAudioTracks().forEach(track => enableAudioTrack(track, enable))
        }


        function disableAudioTracks(stream) {
            enableAudioTracks(stream, false)
        }


        // =[ WebRTC ]========================================================


        async function createConnection() {
            const connection = new RTCPeerConnection()
            debugLog('Created WebRTC connection')
            return connection
        }


        async function closeConnection(connection) {
            connection.close()
            debugLog('Closed WebRTC connection')
        }


        async function waitForIceCandidates(connection) {
            return new Promise(resolve => {
                connection.addEventListener('icecandidate', onIceCandidate)

                function onIceCandidate(event) {
                    if (event.candidate) return
                    connection.removeEventListener('icecandidate', onIceCandidate)
                    debugLog('WebRTC Ice candidates received')
                    resolve(connection)
                }
            })
        }


        async function createDataChannel(connection) {
            const channel = connection.createDataChannel('data')
            debugLog('Created WebRTC data channel')
            return channel
        }


        async function closeDataChannel(channel) {
            channel.close()
            debugLog('Closed WebRTC data channel')
        }


        async function sendDataChannelMessage(channel, message) {
            channel.send(message)
            debugLog('Sent WebRTC data channel message: ', message)
        }


        async function addTracks(connection, stream) {
            stream.getAudioTracks().forEach(track => {
                connection.addTrack(track, stream)
                debugLog("Created WebRTC audio track for device: " + track.label)
            })
        }


        async function createOffer(connection, options) {
            const offer = await connection.createOffer(options)
            debugLog('Created WebRTC offer')
            return offer
        }


        async function setOffer(connection, offer) {
            const waitForSdp = waitForIceCandidates(connection)
            await connection.setLocalDescription(offer)
            await waitForSdp
            offer.sdp = connection.localDescription.sdp
            debugLog("Applied local WebRTC offer")
            return offer
        }


        async function acceptOffer(connection, offer) {
            await connection.setRemoteDescription(offer)
            debugLog('Applied remote WebRTC offer')
        }
        

        async function createAnswer(connection) {
            const answer = await connection.createAnswer()
            debugLog('Created WebRTC answer')
            return answer
        }


        async function setAnswer(connection, answer) {
            const waitForSdp = waitForIceCandidates(connection)
            await connection.setLocalDescription(answer)
            await waitForSdp
            answer.sdp = connection.localDescription.sdp
            debugLog("Applied local WebRTC answer")
            return answer
        }


        async function acceptAnswer(connection, answer) {
            await connection.setRemoteDescription(answer)
            debugLog('Applied remote WebRTC answer')
        }


        async function createOfferConnection(stream, ontrack) {
            const connection  = await createConnection()
            connection.ontrack = ontrack
            const dataChannel = await createDataChannel(connection)
            if (stream) await addTracks(connection, stream)
            const offer       = await createOffer(connection)
            await setOffer(connection, offer)
            return { connection, dataChannel, localStream: stream, offer }
        }


        async function createAnswerConnection(offer, stream, ontrack, ondatachannel) {
            const connection  = await createConnection()
            connection.ontrack = ontrack
            connection.ondatachannel = ondatachannel
            if (stream) await addTracks(connection, stream)
            await acceptOffer(connection, offer)
            const answer      = await createAnswer(connection)
            await setAnswer(connection, answer)
            return { connection, localStream: stream, offer, answer }
        }


        // =[ Messaging ]=====================================================


        async function prepareMessaging() {
            const url = `${PROTO}://${SERVER}${PORT ? ':' + PORT : ''}${PATH}`
            const iframe = await createAndLoadMessagingIframe(url)
            const sendMessage = (data, timeout) => _sendMessage(iframe, data, timeout)
            return {
                messagingUrl:    url,
                messagingIframe: iframe,
                sendMessage,
            }
        }


        async function createAndLoadMessagingIframe(sourceUrl) {
            const iframe = document.createElement('iframe')
            iframe.setAttribute('style', "display:none")
            iframe.src = sourceUrl
            document.body.appendChild(iframe)
            return new Promise(resolve => {
                iframe.addEventListener('load', onLoad)
                function onLoad() {
                    iframe.removeEventListener('load', onLoad)
                    debugLog('Loaded messaging iframe')
                    resolve(iframe)
                }
            })
        }


        async function _sendMessage(iframe, data, timeout=MESSAGE_TIMEOUT) {
            const messageId = uuidv4()
            
            return new Promise((resolve, reject) => {
                const timer = !timeout ? undefined : setTimeout(() => {
                    window.removeEventListener('message', onMessage)
                    reject(Object.assign(new Error('response timed out'), { name: 'AbortError'}))
                }, timeout + 1000)
                
                window.addEventListener('message', onMessage)
                let message = { _id: messageId, data }
                if (timeout) message._timeout = timeout
                debugLog('Sending message: ', data)
                iframe.contentWindow.postMessage(message, '*')
                
                function onMessage(event) {
                    // debugLog(event)
                    const { _id, data, error, error_name } = event.data
                    if (_id === messageId) {
                        window.removeEventListener('message', onMessage)
                        clearTimeout(timer)
                        if (error) {
                            const errorData = new Error(error)
                            if (error_name) errorData.name = error_name
                            reject(errorData)
                        } else {
                            debugLog('Received message: ', data)
                            resolve(data)
                        }
                    }
                }
            })
        }


        // =[ Utility ]=======================================================


        function debugLog(message) {
            // Log only if DEBUG_LOGGING is enabled
            if (DEBUG_LOGGING) console.log(...arguments)
        }


        function uuidv4() {
            // Generate a random UUID version 4 string
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8)
                return v.toString(16)
            });
        }
    })()</script>

</body>
</html>