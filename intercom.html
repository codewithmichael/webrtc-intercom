<!--
Project: WebRTC Intercom
Created: 2020.05.31
Author:  Michael Spencer <code.with.michael@gmail.com>
License: MIT
-->
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Intercom</title>
    <script>
        "use strict";
        
        const DEFAULT_USERNAME = ''

        // Messaging server info
        const PROTO  = 'http'
        const SERVER = 'localhost'
        const PORT   = 8080
        const PATH   = '/jsonLoader'

        const MESSAGE_TIMEOUT   = 3000
        const LONG_POLL_TIMEOUT = 30000
        const RECONNECT_TIMEOUT = 3000

        const DEBUG_LOGGING    = true
    </script>
    <style>
        :root {
            --wallpaper-dark: #dfa849;
            --wallpaper-light: #e7bd74;

            --faceplate-image: url('assets/metal.png');
            --faceplate-holes-image: url('assets/holes.png');

            --light-off-image: url('assets/light-off.png');
            --light-on-image: url('assets/light-on.png');
            --light-flash-image: url('assets/light-on.png');

            --switch-on-image: url('assets/switch-on.png');
            --switch-off-image: url('assets/switch-off.png');
            --switch-center-on-image: url('assets/switch-center.png');
            --switch-center-off-image: url('assets/switch-off.png');
            
            --connected-light-off-image: url('assets/connected-light-off.png');
            --connected-light-on-image: url('assets/connected-light-on.png');
            
            --talk-light-off-image: url('assets/talk-light-off.png');
            --talk-light-on-image: url('assets/talk-light-on.png');
        }

        * {
            font-family: Arial, Helvetica, sans-serif;
            user-select: none;
        }
        
        
        html {
            background: repeating-linear-gradient(
                to right,
                var(--wallpaper-light),
                var(--wallpaper-dark) 2px,
                var(--wallpaper-dark) 108px,
                var(--wallpaper-light) 110px,
                var(--wallpaper-light) 150px
            );
        }
        
        
        [data-type="template"] {
            display: none !important;
        }
        
        
        #faceplate {
            display: block;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-image: var(--faceplate-image);
            background-position: left top;
            width: 650px;
            height: 500px;
            border-radius: 10px;
            box-shadow: 2px 10px 15px -5px;
        }
        #faceplate::before {
            content: '';
            display: block;
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            border: 10px solid #000;
            border-top: 10px solid #f7f7ce;
            border-left: 10px solid #f7f78c;
            border-radius: 10px;
            opacity: 0.1
        }
        #faceplate::after {
            content: '';
            display: block;
            position: absolute;
            background-image: var(--faceplate-holes-image);
            width: 299px;
            height: 292px;
            top: 60px;
            left: 50px
        }
        
        
        #name-input {
            display: block;
            position: absolute;
            width: 300px;
            top: 25px;
            right: 65px;
            outline: none;
            border: 0;
            border-bottom: 1px solid rgba(100, 100, 50, .2);
            font-size: 26px;
            user-select: text;
            background-color: transparent;
            text-align: right;
        
            font-weight: bold;
            color: #000c;
            text-shadow:
                -1px -1px 3px #fff3,
                1px 2px 2px #0006,
                1px 2px 10px #fff6;
        }
        #name-input::placeholder {
            color: #000c;
            opacity: 1;
        }
        
        
        #user-list {
            display: block;
            position: absolute;
            right: 0px;
            top: 60px;
            list-style: none;
            margin: 0;
            padding: 20px 10px 10px 20px;
            font-size: 16px;
            margin: 10px 0;
            min-width: 220px;
            max-width: 270px;
            height: 400px;
            overflow: hidden auto;
            z-index: 1;
        
            border: 1px solid #0006;
            border-right: 0;
            border-bottom: 0;
            border-radius: 10px 0 10px 0;
            background-color: #0001;
            box-shadow: inset 10px 20px 30px 0px #000;
        }
        #user-list li:not(:last-child) {
            margin-bottom: 5px;
        }
        
        
        #user-list .not-connected,
        #user-list .no-users {
            text-align: center;
            padding: 10px;
            font-weight: bold;
            color: #000c;
            text-shadow:
                -1px -1px 3px #fff3,
                1px 2px 2px #0006,
                1px 2px 10px #fff6;
        }
        
        
        #user-list .user-item {
            display: block;
            position: relative;
            padding-right: 55px;
            margin-top: 2px;
/*             ! height: 45px; */
        }
        #user-list .user-item >* {
            display: inline-block;
            line-height: 20px;
            vertical-align: middle;
        }
        
        
        #user-list audio {
            display: none !important;
        }
        
        
        #user-list .light {
            position: relative;
            top: 2px;
            width: 40px;
            height: 40px;
            background:
                var(--light-off-image) center center / 40px 40px no-repeat;
            opacity: 0.8;
        }
        #user-list .light.on {
            background-image: var(--light-on-image);
        }
        @keyframes light-flashing{
            0%  { background-image: var(--light-flash-image); }
            49% { background-image: var(--light-flash-image); }
            50% { background-image: var(--light-off-image); }
            100%{ background-image: var(--light-off-image); }
        }
        #user-list .light.flashing {
            animation: light-flashing 1s infinite;
        }
        #user-list .light.flashing:hover::before {
            display: block;
            position: absolute;
            white-space: nowrap;
            content: "click to cancel";
            color: #fff;
            font-size: 10px;
            line-height: 10px;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            height: 10px;
            border: 1px solid #fff;
            background-color: #222;
            padding: 2px;
        }
        
        
        #user-list .toggle {
            display: inline-block;
            position: relative;
            content:'';
            width: 28px;
            height: 50px;
            background: var(--switch-off-image) center center / 28px 50px no-repeat;
        }
        #user-list .toggle.on {
            background-image: var(--switch-on-image);
        }
        @keyframes toggle-waiting {
            0%  { background-image: var(--switch-center-on-image); }
            49% { background-image: var(--switch-center-on-image); }
            50% { background-image: var(--switch-center-off-image); }
            100%{ background-image: var(--switch-center-off-image); }
        }
        #user-list .toggle.waiting {
            /* animation: toggle-waiting 1s infinite; */
            background-image: var(--switch-center-on-image)
        }
        
        
        #user-list .name {
            font-weight: bold;
            color: #000c;
            text-shadow:
                -1px -1px 3px #fff3,
                1px 2px 2px #0006,
                1px 2px 10px #fff6;
        }
        
        
        #user-list .button {
            position: absolute;
            top: 15px;
            right: 25px;
            width: 20px;
            height: 20px;
            border-radius: 20px;
            border: 1px solid #555;
            background-color: #222;
            box-shadow:
                inset 2px 6px 3px -3px #fff,
                inset -2px -2px 3px -3px #fff;
        }
        #user-list .button.highlight {
            background-color: #0c6;
        }
        #user-list .button.pressed {
            border: 1px solid #444;
            box-shadow:
                inset 1px 2px 2px 2px #000,
                inset 1px 3px 3px 1px #fff;
        }
        #user-list .button::before {
            display: inline-block;
            position: relative;
            content: "talk";
            color: #222;
            font-size: 10px;
            line-height: 24px;
            height: 24px;
            top: -3px;
            left: -3px;
            border: 1px solid #ccc3;
            border-right: 0px;
            border-radius: 20px 0 0 20px;
            background-color: #f7f7f730;
            box-shadow: inset 18px 8px 10px -2px #000a;
            padding: 0 5px 0 26px;
            z-index: -1;
        }


        #connected-light {
            display: block;
            position: absolute;
            top: 15px;
            left: 8px;
            width: 76px;
            height: 72px;
            background: var(--connected-light-off-image) top left / 76px 72px no-repeat;
        }
        #connected-light:hover::before {
            display: block;
            position: absolute;
            white-space: nowrap;
            content: "click to connect";
            color: #fff;
            font-size: 10px;
            line-height: 10px;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            height: 10px;
            border: 1px solid #fff;
            background-color: #222;
            padding: 2px;
        }
        #connected-light.on {
            background-image: var(--connected-light-on-image)
        }
        #connected-light.on:hover::before {
            display: block;
            position: absolute;
            white-space: nowrap;
            content: "click to disconnect";
            color: #fff;
            font-size: 10px;
            line-height: 10px;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            height: 10px;
            border: 1px solid #fff;
            background-color: #222;
            padding: 2px;
        }
        @keyframes connected-light-flashing {
            0%  { background-image: var(--connected-light-on-image); }
            24% { background-image: var(--connected-light-on-image); }
            25% { background-image: var(--connected-light-off-image); }
            100%{ background-image: var(--connected-light-off-image); }
        }
        #connected-light.flashing {
            animation: connected-light-flashing 3s infinite;
        }
        #connected-light.flashing:hover::before {
            display: block;
            position: absolute;
            white-space: nowrap;
            content: "reconnecting...";
            color: #fff;
            font-size: 10px;
            line-height: 10px;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            height: 10px;
            border: 1px solid #fff;
            background-color: #222;
            padding: 2px;
        }


        #talk-light {
            display: block;
            position: absolute;
            bottom: 5px;
            left: 7px;
            width: 91px;
            height: 91px;
            background: var(--talk-light-off-image) top left / 91px 91px no-repeat;
        }
        #talk-light.on {
            background-image: var(--talk-light-on-image)
        }

    </style>
</head>
<body>

    <div id="faceplate">
        <input id="name-input" type="text" placeholder="Enter User Name"/>
        <ul id="user-list">
            <li class="not-connected" data-type="template">Not connected</li>
            <li class="no-users" data-type="template">No other users connected</li>
            <li class="user-item" data-type="template">
                <audio autoplay></audio>
                <span class="toggle"></span>
                <span class="light"></span>
                <span class="name">UserName</span>
                <span class="button"></span>
            </li>
        </ul>
        <span id="connected-light"></span>
        <span id="talk-light"></span>
    </div>


    <script>(async () => {
        "use strict";


        //-[ Setup ]----------------------------------------------------------


        const {
            inputAudioStream,
            nameInput,
            userList,
            connectedLight,
            talkLight,
            updateUserItems,
            sendMessage,
        } = Object.assign(this,
            await prepareInputAudioStream(),
            await prepareUserInterface(),
            await prepareMessaging(),
        )
        
        
        //-[ App ]------------------------------------------------------------


        let state = this.state = {
            user: { name: DEFAULT_USERNAME },
            users: [],
            connections: {}  // { <key=user_name>: { connection, dataChannel, localStream, remoteStream, offer, answer }}
        }
        
        // Mute microphone by default
        disableAudioTracks(inputAudioStream)

        // Initialize empty user list
        updateUserItems()

        // Handle name change
        if (nameInput.value) {
            nameInput.value = nameInput.value.trim()
            if (nameInput.value) state.user.name = nameInput.value
        }
        nameInput.value = state.user.name
        nameInput.onblur = () => {
            const name = nameInput.value.trim()
            nameInput.value = name
            register(name)
                .catch(error => {
                    console.error(error)
                    nameInput.value = state.user.name || ''
                    nameInput.focus()
                })
        }

        // Autoconnect
        const { name } = state.user
        if (name) {
            await register(name)
                .catch(error => {
                    console.error(error)
                    nameInput.value = state.user.name = ''
                })
        } else {
            nameInput.focus()
        }

        // Manual disconnect/reconnect
        connectedLight.onclick = async function() {
            if (state.user.id) {
                sendMessage({ unregister: state.user.id  })
                cancelLoopWait()
                Object.keys(state.connections).forEach(name => disconnect(name))
                state.user.id = undefined
                onReceiveUsers([])
                connectedLight.disable()
            } else {
                // Trigger a name registration attempt
                nameInput.onblur()
            }
        }


        //-[ Data ]-----------------------------------------------------------


        function toUser(data) {
            let { id, name } = data || {}
            if (typeof(id) === 'undefined') id = null
            name = (name || '').trim()
            return { id, name }
        }


        //-[ Actions ]--------------------------------------------------------

        
        async function register(name) {
            let message = { register: name }
            let { id } = state.user
            if (typeof(id) !== 'undefined' && id != null) {
                message.id = id
            }
            return sendMessage(message)
                .then(({ register: user, users }) => {
                    onReceiveUser(user)
                    onReceiveUsers(users)
                })
                .then(() => {
                    connectedLight.enable()
                    loopWait() // not returned!
                })
        }


        async function performOffer(name) {
            const targetUser = state.users.find(user => user.name === name)
            if (!targetUser) throw new Error('User not found')

            const { userItem } = targetUser
            if (!userItem) throw new Error(`Display element not found for user: ${targetUser.name}`)
            
            await disconnect(name)
            const localStream = inputAudioStream ? inputAudioStream.clone() : undefined
            disableAudioTracks(localStream)

            userItem.toggle.wait()
            userItem.light.flash()

            const info = { name }
            Object.assign(info, await createOfferConnection(localStream, onTrack))
            state.connections[name] = info

            const { connection, dataChannel, offer } = info
            dataChannel.onopen  = onOpen
            dataChannel.onclose = onClose
            dataChannel.onmessage = onMessage

            const message = {
                id: state.user.id,
                offer: JSON.stringify(offer),
                name
            }
            const response = sendMessage(message)
                .catch(error => {
                    disconnect(name)
                    throw error
                })

            return { connection, offer, response }

            function onTrack(event) {
                const stream = event.streams[0]
                if (stream) {
                    info.remoteStream = stream
                    if (userItem) userItem.audio.srcObject = stream
                }
                debugLog('Added remote WebRTC audio stream')
            }

            function onOpen(event) {
                userItem.toggle.enable()
                userItem.light.enable()

                userItem.button.onpress   = onPress
                userItem.button.onrelease = onRelease
            }

            function onClose(event) {
                debugLog(`Data connection closed for user: ${name}`)
                disconnect(name)
            }

            function onMessage(event) {
                let { data } = event
                if (!data) return
                let { name } = info
                let { userItem } = state.users.filter(u => u.name === name)[0] || {}
                switch (data) {
                    case "begin_talk":
                        info.isTalking = true
                        if (userItem) userItem.button.highlight()
                        break;
                    case "end_talk":
                        info.isTalking = false
                        if (userItem) userItem.button.unhighlight()
                        break;
                    default:
                        console.error(`Unknown data channel message received: "${data}"`)
                }
            }

            function onPress(event) {
                enableAudioTracks(localStream)
                talkLight.enable()
                if (dataChannel) dataChannel.send("begin_talk")
            }

            function onRelease(event) {
                disableAudioTracks(localStream)
                talkLight.disable()
                if (dataChannel) dataChannel.send("end_talk")
            }
        }


        async function performAnswer(offer, name) {
            const targetUser = state.users.find(user => user.name === name)
            if (!targetUser) throw new Error('User not found')
            
            const { userItem } = targetUser
            if (!userItem) throw new Error(`Display element not found for user: ${targetUser.name}`)
            
            await disconnect(name)
            const localStream = inputAudioStream ? inputAudioStream.clone() : undefined
            disableAudioTracks(localStream)

            const info = { name } // must exist before calling createAnswerConneciton (for onTrack)
            Object.assign(info, await createAnswerConnection(offer, localStream, onTrack, onDataChannel))
            state.connections[name] = info

            let { answer } = info
            answer = JSON.stringify(answer)
            const response = sendMessage({ id: state.user.id, answer, name })
                .catch(error => {
                    disconnect(name)
                    throw error
                })

            
            const { connection } = info
            return { connection, offer, answer, response }

            function onDataChannel(event) {
                info.dataChannel = event.channel
                info.dataChannel.onclose = onClose
                info.dataChannel.onmessage = onMessage

                userItem.toggle.enable()
                userItem.light.enable()

                userItem.button.onpress   = onPress
                userItem.button.onrelease = onRelease
                
                debugLog('Added remote WebRTC data channel')
            }

            function onTrack(event) {
                const stream = event.streams[0]
                if (stream) {
                    info.remoteStream = stream
                    if (userItem) userItem.audio.srcObject = stream
                }
                debugLog('Added remote WebRTC audio stream')
            }

            function onClose(event) {
                debugLog(`Data connection closed for user: ${name}`)
                disconnect(name)
            }

            function onMessage(event) {
                let { data } = event
                if (!data) return
                let { name } = info
                let { userItem } = state.users.filter(u => u.name === name)[0] || {}
                switch (data) {
                    case "begin_talk":
                        info.isTalking = true
                        if (userItem) userItem.button.highlight()
                        break;
                    case "end_talk":
                        info.isTalking = false
                        if (userItem) userItem.button.unhighlight()
                        break;
                    default:
                        console.error(`Unknown data channel message received: "${data}"`)
                }
            }

            function onPress(event) {
                let { localStream, dataChannel } = info || {}
                if (localStream) {
                    enableAudioTracks(localStream)
                    talkLight.enable()
                }
                if (dataChannel) {
                    dataChannel.send("begin_talk")
                }
            }

            function onRelease(event) {
                let { localStream, dataChannel } = info || {}
                if (localStream) disableAudioTracks(localStream)
                talkLight.disable()
                if (dataChannel) dataChannel.send("end_talk")
            }
        }


        async function disconnect(name) {
            const info = state.connections[name]
            if (info) {
                delete state.connections[name]
                const targetUser = state.users.find(user => user.name === name)
                const userItem = (targetUser || {}).userItem
                const {
                    connection,
                    dataChannel,
                    localStream,
                    remoteStream
                } = info
                if (userItem) {
                    userItem.toggle.disable()
                    userItem.light.disable()
                    userItem.audio.srcObject  = undefined
                    userItem.button.onpress   = undefined
                    userItem.button.onrelease = undefined
                }
                if (localStream)  disableAudioTracks(localStream)
                if (remoteStream) disableAudioTracks(remoteStream)
                if (dataChannel)  await closeDataChannel(dataChannel)
                if (connection)   await closeConnection(connection)
                debugLog('Disconnected from user: ' + targetUser.name)
                return true
            }
            return false
        }


        var _cancelLoopWait
        function cancelLoopWait() {
            if (!_cancelLoopWait) _cancelLoopWait = []
            _cancelLoopWait.forEach(cancel => cancel())
            _cancelLoopWait.length = 0
        }


        async function loopWait() {
            let cancelled = false

            cancelLoopWait()
            _cancelLoopWait.push(cancel)
            return startLoop()

            function cancel() {
                cancelled = true
            }

            async function startLoop() {
                while (!cancelled && state.user && state.user.id) {
                    await sendMessage({ wait: state.user.id }, LONG_POLL_TIMEOUT)
                        .then(response => {
                            if (cancelled) return
                            let { messages } = response
                            if (messages) for (let message of messages) {
                                onReceiveMessage(message)
                            }
                        })
                        .catch(error => {
                            if (error.name === 'AbortError') return
                            console.error(error)
                            connectedLight.disable()
                            cancel()
                            attempReconnect()
                        })
                }

                async function attempReconnect() {
                    let cancelledReconnect = false

                    cancelLoopWait()
                    _cancelLoopWait.push(cancelReconnect)

                    connectedLight.flash()
                    const users = Object.keys(state.connections)
                        .map(k => state.connections[k])
                        .filter(({ offer, answer }) => offer && answer)
                        .map(({ name }) => ({ name }))
                    onReceiveUsers(users)
                    debugLog('Server connection lost')
                    let timer = setInterval(() => {
                        if (cancelledReconnect) {
                            clearInterval(timer)
                            return
                        }
                        register(nameInput.value)
                            .then(() => {
                                clearInterval(timer)
                                connectedLight.enable()
                                debugLog('Server connection reestablished')
                            })
                            .catch(error => debugLog('Reconnect attempt failed'))
                    }, RECONNECT_TIMEOUT)

                    function cancelReconnect() {
                        cancelledReconnect = true
                    }
                }
            }
        }


        //-[ Events ]--------------------------------------------------------


        function onReceiveMessage(message)
        {
            if (!message || !state.user || !state.user.id) return

            let { register, unregister, offer, answer, reject } = message

            if (register) {
                let { register: user, users } = message
                onReceiveUser(user)
                onReceiveUsers(users)
            } else if (unregister) {
                let { unregister: user, users } = message
                disconnect(user.name)
                onReceiveUsers(users)
            } else if (offer) {
                let { name } = message
                onReceiveOffer(offer, name)
                    .catch(error => {
                        disconnect(name)
                        return error
                    })
            } else if (answer) {
                let { name } = message
                onReceiveAnswer(answer, name)
                    .catch(error => {
                        disconnect(name)
                        return error
                    })
            } else if (reject) {
                let { reject: user } = message
                let { name } = user
                onReceiveReject(name)
                    .catch(error => {
                        disconnect(name)
                        return error
                    })
            }
        }


        function onReceiveUser(user) {
            let { id, name, old_name } = user
            if (id) {
                user = toUser(user)
                state.user = user
                nameInput.value = name
            } else if (old_name) {
                if (state.connections[old_name]) {
                    state.connections[name] = state.connections[old_name]
                    state.connections[name].name = name
                    delete state.connections[old_name]
                }
            }
        }


        function onReceiveUsers(users) {
            users = (users || [])
                .filter(user => user.name !== state.user.name)
                .map(toUser)
            state.users = users
            let userItems = state.userItems = updateUserItems(state.user, users)

            userItems.forEach((userItem, index) => {
                const user = users[index]
                user.userItem = userItem

                const { audio, light, toggle, name, button } = userItem
                let info = state.connections[user.name]
                let {
                    connection,
                    offer,
                    answer,
                    remoteStream,
                    isTalking
                } = info || {}

                audio.srcObject  = remoteStream
                light.onclick    = onLightClick
                toggle.onclick   = onToggleClick
                name.onclick     = onNameClick

                if (isTalking) button.highlight()

                if (offer) {
                    if (connection) {
                        if (answer) {
                            toggle.enable()
                            light.enable()
                            button.onpress   = onButtonPress
                            button.onrelease = onButtonRelease
                        } else {
                            toggle.wait()
                            light.flash()
                        }
                    } else {
                        light.flash()
                    }
                }

                function onToggleClick() {
                    let info = state.connections[user.name]
                    let { connection, offer, answer } = info || {}
                    if (!info) {
                        // No connection: Make an offer
                        performOffer(user.name)
                    } else if (offer && !connection) {
                        // Have a connection offer: Accept offer
                        performAnswer(offer, user.name)
                    } else {
                        // Connected: Disconnect
                        disconnect(user.name)
                        if (connection && offer && !answer) {
                            // Other user hasn't accepted connection offer
                            sendMessage({ id: state.user.id, reject: user.name })
                        }
                    }
                }

                function onLightClick() {
                    let { connection, offer, answer } = state.connections[user.name] || {}
                    if (offer && !answer) {
                        disconnect(user.name)
                        sendMessage({ id: state.user.id, reject: user.name })
                    }
                }

                function onNameClick() {
                    if (!toggle.isEnabled()) onToggleClick()
                }

                function onButtonPress(event) {
                    let { localStream, dataChannel } = state.connections[user.name] || {}
                    if (localStream) {
                        enableAudioTracks(localStream)
                        talkLight.enable()
                    }
                    if (dataChannel) dataChannel.send("begin_talk")
                }

                function onButtonRelease(event) {
                    let { localStream, dataChannel } = state.connections[user.name] || {}
                    if (localStream) disableAudioTracks(localStream)
                    talkLight.disable()
                    if (dataChannel) dataChannel.send("end_talk")
                }
            })
        }


        async function onReceiveOffer(offer, name) {
            let sourceUser = state.users.filter(user => user.name === name)[0]
            if (!sourceUser) throw new Error(`Received offer from unknown user "${name}"... skipping`)

            let { userItem } = sourceUser
            if (!userItem) throw new Error(`Display element not found for user: ${sourceUser.name}`)
            
            await disconnect(name)
            offer = JSON.parse(offer)
            state.connections[name] = { offer }

            userItem.light.flash()
        }


        async function onReceiveAnswer(answer, name) {
            let sourceUser = state.users.filter(user => user.name === name)[0]
            if (!sourceUser) throw new Error(`Received answer from unknown user "${name}"... skipping`)

            let info = state.connections[name]
            let { connection, offer } = info || {}
            if (!info || !connection || !offer || info.answer) {
                throw new Error(`Received unprompted answer from user "${name}"... skipping`)
            }

            answer = JSON.parse(answer)
            return acceptAnswer(connection, answer)
                .then(() => {
                    info.answer = answer
                    return answer
                })
                .catch(error => {
                    disconnect(name)
                    throw error
                })
        }


        async function onReceiveReject(name) {
            disconnect(name)
        }


        // =[ UI ]============================================================


        async function prepareUserInterface() {
            const nameInput      = document.querySelector('#name-input')
            const userList       = document.querySelector('#user-list')
            const connectedLight = document.querySelector('#connected-light')
            const talkLight      = document.querySelector('#talk-light')

            const templates = {
                userItem:     userList.querySelector('.user-item[data-type="template"]'),
                notConnected: userList.querySelector('.not-connected[data-type="template"]'),
                noUsers:      userList.querySelector('.no-users[data-type="template"]'),
            }

            Object.keys(templates).forEach(k => { templates[k].remove() })
            const updateUserItems = (user, users) => _updateUserItems(
                user, users, userList, templates.userItem, templates.noUsers, templates.notConnected)

            nameInput.onfocus   = onNameInputFocus
            nameInput.onkeydown = onNameInputKeyDown

            connectedLight.isEnabled    = function() { return this.classList.contains('on') }
            connectedLight.enable       = function() { this.cancelFlash(); this.classList.add('on') }
            connectedLight.disable      = function() { this.cancelFlash(); this.classList.remove('on') }
            connectedLight.toggle       = function() { this.isEnabled() ? this.disable() : this.enable() }
            connectedLight.isFlashing   = function() { return this.classList.contains('flashing') }
            connectedLight.flash        = function() { this.classList.remove('on'); this.classList.add('flashing') }
            connectedLight.cancelFlash  = function() { this.classList.remove('flashing') }

            talkLight.isEnabled         = function() { return this.classList.contains('on') }
            talkLight.enable            = function() { this.cancelFlash(); this.classList.add('on') }
            talkLight.disable           = function() { this.cancelFlash(); this.classList.remove('on') }
            talkLight.toggle            = function() { this.isEnabled() ? this.disable() : this.enable() }
            talkLight.isFlashing        = function() { return this.classList.contains('flashing') }
            talkLight.flash             = function() { this.classList.remove('on'); this.classList.add('flashing') }
            talkLight.cancelFlash       = function() { this.classList.remove('flashing') }

            return {
                templates,
                nameInput, userList, connectedLight, talkLight,
                updateUserItems
            }
            
            function onNameInputFocus(event) {
                this.select()
            }

            function onNameInputKeyDown(event) {
                if (event.key === 'Enter') this.blur()
            }
        }

        
        function _updateUserItems(user, users, userList,
            userItemTemplate, noUsersTemplate, notConnectedTemplate)
        {
            userList.innerHTML = ''
            if (!users || !users.length) {
                const noUsers = user && user.id ?
                    noUsersTemplate.cloneNode(true) :
                    notConnectedTemplate.cloneNode(true)
                delete noUsers.dataset.type
                userList.appendChild(noUsers)
                return []
            } else {
                return (users || [])
                    .map(user => _createUserItem(user, userItemTemplate))
                    .map(userItem => (userList.appendChild(userItem), userItem))
            }
        }


        function _createUserItem(user, template) {
            const userItem = template.cloneNode(true)
            delete userItem.dataset.type

            const audio  = userItem.querySelector('audio')
            const name   = userItem.querySelector('.name')
            const toggle = userItem.querySelector('.toggle')
            const button = userItem.querySelector('.button')
            const light  = userItem.querySelector('.light')

            name.innerHTML     = user.name

            toggle.isEnabled   = function() { return this.classList.contains('on') }
            toggle.isWaiting   = function() { return this.classList.contains('waiting') }
            toggle.isDisabled  = function() { return !this.isEnabled() && !this.isWaiting() }
            toggle.enable      = function() { if (this.isEnabled()) return; this.classList.remove('waiting'); this.classList.add('on'); if (this.onenable) this.onenable() }
            toggle.disable     = function() { if (!this.isEnabled() && !this.isWaiting()) return; this.classList.remove('on', 'waiting'); if (this.ondisable) this.ondisable() }
            toggle.wait        = function() { if (this.isWaiting()) return; this.classList.remove('on'); this.classList.add('waiting'); if (this.onwait) this.onwait() }
            toggle.onenable    = undefined
            toggle.ondisable   = undefined
            toggle.onwait      = undefined

            button.isPressed   = function() { return this.classList.contains('pressed') }
            button.onmousedown = function() { if (!toggle.isEnabled()) return; this.classList.add('pressed'); if (this.onpress) this.onpress() }
            button.onmouseup   =
            button.onmouseout  = function() { this.classList.remove('pressed'); if (this.onrelease) this.onrelease() }
            button.onpress     = undefined
            button.onrelease   = undefined
            button.isHighlighted = function() { return this.classList.contains('highlight') }
            button.highlight     = function() { return this.classList.add('highlight') }
            button.unhighlight   = function() { return this.classList.remove('highlight') }
            
            light.isEnabled    = function() { return this.classList.contains('on') }
            light.enable       = function() { this.cancelFlash(); this.classList.add('on') }
            light.disable      = function() { this.cancelFlash(); this.classList.remove('on') }
            light.toggle       = function() { this.isEnabled() ? this.disable() : this.enable() }
            light.isFlashing   = function() { return this.classList.contains('flashing') }
            light.flash        = function() { this.classList.remove('on'); this.classList.add('flashing') }
            light.cancelFlash  = function() { this.classList.remove('flashing') }

            Object.assign(userItem, { audio, name, button, toggle, light })
            
            return userItem
        }


        // =[ Audio ]=========================================================


        async function prepareInputAudioStream() {
            if (!navigator.mediaDevices) throw new Error("No media devices available")
            const inputAudioStream = await navigator.mediaDevices
                .getUserMedia({ audio: true })
                .then(stream => {
                    let track = stream.getAudioTracks()[0]
                    if (track) debugLog("Using audio device: " + track.label)
                    return stream
                })
                .catch(error => { console.error(error) })
            return { inputAudioStream }
        }


        function enableAudioTrack(track, enable=true) {
            if (track.enabled === enable) return
            track.enabled = enable
            debugLog(`${enable ? "Enabled" : "Disabled"} audio device: ${track.label}`)
        }


        function enableAudioTracks(stream, enable=true) {
            if (!stream) return
            stream.getAudioTracks().forEach(track => enableAudioTrack(track, enable))
        }


        function disableAudioTracks(stream) {
            enableAudioTracks(stream, false)
        }


        // =[ WebRTC ]========================================================


        async function createConnection() {
            const connection = new RTCPeerConnection()
            debugLog('Created WebRTC connection')
            return connection
        }


        async function closeConnection(connection) {
            connection.close()
            debugLog('Closed WebRTC connection')
        }


        async function waitForIceCandidates(connection) {
            return new Promise(resolve => {
                connection.addEventListener('icecandidate', onIceCandidate)

                function onIceCandidate(event) {
                    if (event.candidate) return
                    connection.removeEventListener('icecandidate', onIceCandidate)
                    debugLog('WebRTC Ice candidates received')
                    resolve(connection)
                }
            })
        }


        async function createDataChannel(connection) {
            const channel = connection.createDataChannel('data')
            debugLog('Created WebRTC data channel')
            return channel
        }


        async function closeDataChannel(channel) {
            channel.close()
            debugLog('Closed WebRTC data channel')
        }


        async function sendDataChannelMessage(channel, message) {
            channel.send(message)
            debugLog('Sent WebRTC data channel message: ', message)
        }


        async function addTracks(connection, stream) {
            stream.getAudioTracks().forEach(track => {
                connection.addTrack(track, stream)
                debugLog("Created WebRTC audio track for device: " + track.label)
            })
        }


        async function createOffer(connection, options) {
            const offer = await connection.createOffer(options)
            debugLog('Created WebRTC offer')
            return offer
        }


        async function setOffer(connection, offer) {
            const waitForSdp = waitForIceCandidates(connection)
            await connection.setLocalDescription(offer)
            await waitForSdp
            offer.sdp = connection.localDescription.sdp
            debugLog("Applied local WebRTC offer")
            return offer
        }


        async function acceptOffer(connection, offer) {
            await connection.setRemoteDescription(offer)
            debugLog('Applied remote WebRTC offer')
        }
        

        async function createAnswer(connection) {
            const answer = await connection.createAnswer()
            debugLog('Created WebRTC answer')
            return answer
        }


        async function setAnswer(connection, answer) {
            const waitForSdp = waitForIceCandidates(connection)
            await connection.setLocalDescription(answer)
            await waitForSdp
            answer.sdp = connection.localDescription.sdp
            debugLog("Applied local WebRTC answer")
            return answer
        }


        async function acceptAnswer(connection, answer) {
            await connection.setRemoteDescription(answer)
            debugLog('Applied remote WebRTC answer')
        }


        async function createOfferConnection(stream, ontrack) {
            const connection  = await createConnection()
            connection.ontrack = ontrack
            const dataChannel = await createDataChannel(connection)
            if (stream) await addTracks(connection, stream)
            const offer       = await createOffer(connection)
            await setOffer(connection, offer)
            return { connection, dataChannel, localStream: stream, offer }
        }


        async function createAnswerConnection(offer, stream, ontrack, ondatachannel) {
            const connection  = await createConnection()
            connection.ontrack = ontrack
            connection.ondatachannel = ondatachannel
            if (stream) await addTracks(connection, stream)
            await acceptOffer(connection, offer)
            const answer      = await createAnswer(connection)
            await setAnswer(connection, answer)
            return { connection, localStream: stream, offer, answer }
        }


        // =[ Messaging ]=====================================================


        async function prepareMessaging() {
            const url = (PROTO ? `${PROTO}:` : '') + `//${SERVER}${PORT ? ':' + PORT : ''}${PATH}`
            const iframe = await createAndLoadMessagingIframe(url)
            const sendMessage = (data, timeout) => _sendMessage(iframe, data, timeout)
            return {
                messagingUrl:    url,
                messagingIframe: iframe,
                sendMessage,
            }
        }


        async function createAndLoadMessagingIframe(sourceUrl) {
            const iframe = document.createElement('iframe')
            iframe.setAttribute('style', "display:none")
            iframe.src = sourceUrl
            document.body.appendChild(iframe)
            return new Promise(resolve => {
                iframe.addEventListener('load', onLoad)
                function onLoad() {
                    iframe.removeEventListener('load', onLoad)
                    debugLog('Loaded messaging iframe')
                    resolve(iframe)
                }
            })
        }


        async function _sendMessage(iframe, data, timeout=MESSAGE_TIMEOUT) {
            const messageId = uuidv4()
            
            return new Promise((resolve, reject) => {
                const timer = !timeout ? undefined : setTimeout(() => {
                    window.removeEventListener('message', onMessage)
                    reject(Object.assign(new Error('response timed out'), { name: 'AbortError'}))
                }, timeout + 1000)
                
                window.addEventListener('message', onMessage)
                let message = { _id: messageId, data }
                if (timeout) message._timeout = timeout
                debugLog('Sending message: ', data)
                iframe.contentWindow.postMessage(message, '*')
                
                function onMessage(event) {
                    // debugLog(event)
                    const { _id, data, error, error_name } = event.data
                    if (_id === messageId) {
                        window.removeEventListener('message', onMessage)
                        clearTimeout(timer)
                        if (error) {
                            const errorData = new Error(error)
                            if (error_name) errorData.name = error_name
                            reject(errorData)
                        } else {
                            debugLog('Received message: ', data)
                            resolve(data)
                        }
                    }
                }
            })
        }


        // =[ Utility ]=======================================================


        function debugLog(message) {
            // Log only if DEBUG_LOGGING is enabled
            if (DEBUG_LOGGING) console.log(...arguments)
        }


        function uuidv4() {
            // Generate a random UUID version 4 string
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8)
                return v.toString(16)
            });
        }
    })()</script>

</body>
</html>